// Задача1
// Ви повинні реалізувати функцію, яка повертає різницю між
// найбільшим та найменшим значенням у списку , отриманому як аргумент
// функції. Масив, який отримує функція як аргумент, може містити позитивні
// та негативні числа. Якщо масив порожній або має 1 значення, поверніть нуль.
// Спочатку масив буде поданий у невідсортованому вигляді.
// arr([1, 2, 3, -4]); // вернет 7, потому что: 3 - (-4) == 7
// arr([16]) => 0

const arr = [100, 50, -5, 2];
//дан массив чисел

function diffMaxMin(arr) {

    //делаем проверку на длинну массива, если меньше 2 - выводим нуль, иначе
    if (arr.length < 2) {
        return 0;

        //создаем переменные для максимального и минимального значений, и с помощью метода для поиска мах/мин чисел,
        //а также оператора расширения, находим эти числа в массиве, и помещаем их в переменные
    } else {
        const maxVal = Math.max(...arr);
        const minVal = Math.min(...arr);

        //выводим разницу
        return maxVal - minVal;
    }
}

// console.log(diffMaxMin(arr));





// Задача2
// Напишіть функцію, яка приймає рядок і число. Поверніть у вигляді
// масиву тільки ті слова, довжина яких перевищує число.


//создаем функцию с двумя параметрами(строка, длинна)
function filterWordsByLength(str, length) {

    //заполняем массив слов элементами, преобразованными из строки, с помощью метода сплит 
    let words = str.split(" ");

    //заполняем массив словами, длинна которых, превышает заданную, с помощью метода фильтер  
    let longWords = words.filter(word => word.length > length);

    //выводим полученный массив    
    return longWords;
}
//   console.log(filterWordsByLength("ronaldo messi neymar mbappe pele maradona figo pepe zidane", 5));





//   Задача3
// Напишіть функцію, яка повертає true, якщо перший переданий
// аргумент (рядок) закінчується другим аргументом (також рядком).
// Приклад:
// solution('abc', 'bc') => true
// solution('abc', 'd') => false


//создаем функцию с параметрами (строка, конец)
function solution(str, ending) {

    //с помощью метода endsWith определяем сходство параметра "конец", с окончанием строки, и выводим результат 
    return str.endsWith(ending);
}

//   console.log(solution("Mbappe", "ppe"));


// Задача4
// Напишіть функцію, яка отримує масив цілих чисел і повертає масив
// середніх значень кожного цілого числа та його послідовника, якщо він є.
// Приклад:
// averages([2, -2, 2, -2, 2]), [0, 0, 0, 0]
// averages([1, 3, 5, 1, -10]), [2, 4, 3, -4.5]


//создаем функцию с параметром массив
function averages(arr) {

    //создаем в ней пустой массив
    const result = [];

    //с помощью цикла перебираем элементы массива
    for (let i = 0; i < arr.length - 1; i++) {

        // находим среднее значение, складывая элемент массива со следующим разделив на 2
        let avg = (arr[i] + arr[i + 1]) / 2;

        //заполняем пустой массив средними значениями, с помощью метода push()
        result.push(avg);
    }

    //віводим результат
    return result;
}

// console.log(averages([2, -2, 2, -2, 2]));





// Задача5
// Створіть функцію, яка приймає рядок і повертає кількість (кількість)
// голосних, які у ній.
// Приклад:
// countVowels("Celebration") ➞ 5
// countVowels("Palm") ➞ 1

// функція для підрахунку кількості голосних літер у рядку


//создаем функцию с параметром строка
function countVowels(str) {

    //создаем массив со всеми гласными буквами
    const vowels = ["a", "e", "i", "o", "u", "y"];

    //создаем перемнную=счетчик
    let count = 0;

    //с помощью цикла перебираем каждый элемент строки
    for (let i = 0; i < str.length; i++) {


        //при помощи метода includes(), проверяем наличие гласных букв в массиве, при их наличии - увеличиваем значение счетчика на единицу 
        if (vowels.includes(str[i].toLowerCase())) {
            count++;
        }
    }

    //выводим количество гласных букв
    return count;
}

//   console.log(countVowels("CELEBRATION"));
//   console.log(countVowels("Palm"));



// Створіть функцію, яка видаляє літери "a", "b" і "c" з цього рядка і поверне
// змінену версію. Якщо цей рядок не містить "a", "b" або "c", повернути null.
// Приклад:
// removeABC("This might be a bit hard") ➞ "This might e it hrd"
// removeABC("hello world!") ➞ null


//создаем функцию с параметром строка
function removeABC(str) {

    //создаем пустую строку
    //создаем булевую переменную-индикатор, со значением ложь
    let newStr = '';
    let hasABC = false;

    //с помощью цикла перебираем каждый элемент строки
    for (let i = 0; i < str.length; i++) {

        //проверяем является ли элемент строки определенной буквой, если нет - добавляем его в созданную раннее пустую строку,
        // если да, тогда не добавляем, а меняем индикатор на : истина 
        if (str[i] !== 'a' && str[i] !== 'b' && str[i] !== 'c') {
            newStr += str[i];
        } else {
            hasABC = true;
        }
    }

    //если значение индикатора - истина, тогда выводим заполненную нами строку, если ложь - возвращаем null
    return hasABC ? newStr : null;
}

// console.log(removeABC("This might be a bit hard"));
// console.log(removeABC("hello world"));




// Задача 6
// Напишіть JavaScript для пошуку унікальних елементів з двох масивів.
// Приклад:
// console.log(difference([1, 2, 3], [100, 2, 1, 10]));
// ["1", "2", "3", "10", "100"]



//создаем функцию с параметрами два массива
function uniqueness(arr1, arr2) {

    //создаем пустой массив
    const result = [];

    //с ппомощью цикла проходимся по первому массиву 
    for (let i = 0; i < arr1.length; i++) {

        //если в созданном нами массиве нет таких же элементов, как в первом, тогда заполняем наш массив этими элементами из первого массива
        if (!result.includes(arr1[i])) {
            result.push(arr1[i]);
        }
    }
    //точно также проходимся и по второму массиву
    for (let j = 0; j < arr2.length; j++) {
        if (!result.includes(arr2[j])) {
            result.push(arr2[j]);
        }
    }

    //выводим наш массив


    return result
}

// console.log(uniqueness([1, 2, 3, 3, 4, 5, 5, 6, 7, 12], [100, 2, 3, 44, 10, 12, 13, 1, 10]));




// Задача7
// Напишіть функцію, щоб отримати копію об'єкта, де ключі стали
// значеннями, а значення ключами.
// Вхід - {red: "#FF0000", green: "#00FF00", white: "#FFFFFF"}
// вихід - {"#FF0000":"red","#00FF00":"green","#FFFFFF":"white"}


//создаем функцию с параметром обьект
function reverseObject(obj) {

    //создаем пустой обьект
    let reversed = {};

    //с помощью цикла виводим все ключи заданного обьекта,
    for (let key in obj) {

        //при этом создавая новыый ключ value со значением ключа key, и добавляем его в созанный нами, пустой обьект
        let value = obj[key];
        reversed[value] = key;
    }
    return reversed;
}




// Задача8
// Івана Іванова обікрали. Але його речі було застраховано на певну суму.
// Враховуючи вкрадені речі та обмеження страховки, поверніть різницю між
// загальною вартістю цих речей та межею політики.
// Приклад:
// calculateDifference({ "baseball bat": 20 }, 5) ➞ 15
// calculateDifference({ skate: 10, painting: 20 }, 19) ➞ 11
// calculateDifference({ skate: 200, painting: 200, shoes: 1 }, 400) ➞ 1
// Обмеження: Об'єкт завжди повинен містити елементи, сума предметів
// завжди повинна бути більшою за страховку.



//создаем функцию с парметрами обьект предметов и граница страховки
  function calculateDifference(items, insuranceLimit) {

    //переменная содержащая в себе общую стоимость
    let totalValue = 0;
  
    //добавляем стоимость каждого предмета к общей стоимости
    for (let key in items) {
      totalValue += items[key];
    }
  
    //сравниваем общую стоимость с пределом страхования и возвращаем разницу
    return Math.max(0, totalValue - insuranceLimit);
  }
  




// Задача9

// Напишіть функцію, яка приймає три виміри цегли: висоту (a), ширину
// (b) і глибину (c) і повертає істину, якщо ця цегла може поміститися в отвір з
// шириною (w) та висотою (h). Виміри вводить користувач через форму.
// Приклад:
// doesBrickFit(1, 1, 1, 1, 1) ➞ true
// doesBrickFit(1, 2, 1, 1, 1) ➞ true
// doesBrickFit(1, 2, 2, 1, 1) ➞ false
// Обмеження:
// Цеглу можна повернути будь-якою стороною до отвору.
// Ми припускаємо, що цегла підходить, якщо її розміри дорівнюють
// розмірам отвору (тобто розмір цегли повинен бути меншим або дорівнює
// розміру отвору, не строго менше).
// Цегла не можна класти під неортогональним кутом.


  function doesBrickFit(a, b, c, w, h) {
    // проверка, можно ли поместить кирпич относительно длинны (w)
    if ((a <= w && b <= h) || (a <= h && b <= w)) {
      return true;
    }
    // проверка, можно ли поместить кирпич относительно высоты (h)
    if ((a <= h && b <= w) || (a <= w && b <= h)) {
      return true;
    }
    // проверка, можно ли поместить кирпич относительно глубины (c)
    if ((a <= c && b <= h) || (a <= h && b <= c)) {
      return true;
    }
    // если не в одном случае невозможно поместить 
    return false;
  }

//   console.log(doesBrickFit(5,20,20,15,5));
  




// Задача10
// Дано рядок, що містить повне ім'я файлу (наприклад, 'c:
// \WebServers\home\testsite\www\myfile.txt'). Виділіть із цього рядка ім'я файлу
// без розширення.

let filePath = 'c:\\WebServers\\home\\testsite\\www\\myfile.txt';
function fileNameItem(){

//разделяем строку 'filePath', с помощью метода сплит, чтоб получить массив строк,
// который содержит каждую часть пути к файлу. Дальше с помощью метода поп получаем последний элемент массива, который содердит в себе 'myfile.txt'
//
let fileNameWithExtension = filePath.split('\\').pop();

//снова используем метод split()
// для разделения имени файла с расширением, на массив с помощью точки и используем индекс [0], чтобы получить имя файла без расширения
let fileName = fileNameWithExtension.split('.')[0];

//выводим результат
return fileName;
}
// console.log(fileNameItem(filePath)); 




// Задача11
// Дано два рядки. Чи можна перший рядок отримати з другого циклічним
// зрушенням?


function isCyclicShift(str1, str2) {

    //проверяем, имеют ли строки одинаковую длину?
    if (str1.length !== str2.length) {
      return false;
    }
  
    //Если длины строк совпадают, мы осуществляем циклические смещения второй строки и сравниваем их с первой строкой.
    //Если найдено совпадение, возвращаем true, если нет, возвращаем false.
    for (let i = 0; i < str2.length; i++) {
      if (str1 === str2) {
        return true;
      }
      str2 = str2.slice(1) + str2.charAt(0);
    }
  
    return false;
  }
  
  let str1 = "abcde";
  let str2 = "cdeab";
  
//   console.log(isCyclicShift(str1, str2)); 
  

// Задача12

// З елементів масиву a, що складається з 2n елементів, отримати масиви b
// і c наступним чином: вибрати в масиві a два найбільш близькі за значенням
// елемента, менший з них помістити в масив b, а більший - масив c. Виключити
// з розгляду в масиві a ці елементи і продовжити вибір з елементів, що
// залишилися.



function splitArray(a) {
    a.sort(function(a, b) { return a - b; }); // сортируем массив в порядке возрастания

    //создаем два пустых массива
    const b = [];
    const c = [];

    //Проходим по массиву a с шагом 2 и на каждой итерации выбираем два наиболее близких по значению элемента
    for (let i = 0; i < a.length; i += 2) {

        //Добавляем меньший из выбранных элементов в массив b и больший в массив c
      b.push(a[i]);
      c.push(a[i + 1]);
    }

    //возвращаем массивы b, c
    return [b, c];
  }
  

//   let a = [2, 7, 3, 9, 1, 6, 4, 8];
//   let result = splitArray(a);
// //   console.log(result[0]);
// //   console.log(result[1]); 
  



// Задача13
// В заданому масиві найменший елемент помістити на перше місце,
// найменший з тих, що залишилися - на останнє місце, наступний -
// передостаннє і так далі - до середини масиву.


const mas = [5, 3, 8, 1, 4, 2, 7, 6];

// Сортируем массив по возрастанию
mas.sort(function(a, b) {
  return a - b;
});

// Создаем новый массив с переставленными элементами
let result = [];
let length = mas.length;
for(let i = 0; i < length / 2; i++) {
  result[i] = mas[i];
  result[length - i - 1] = mas[i + 1];
}

// перезаписываем отсортированный массив с новым порядком элементов
// mas = result;

console.log(result);
